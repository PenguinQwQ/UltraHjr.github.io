<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ultrahjr.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Welcome to my Ark!">
<meta property="og:type" content="website">
<meta property="og:title" content="Wind&#39;s Blog">
<meta property="og:url" content="https://ultrahjr.github.io/index.html">
<meta property="og:site_name" content="Wind&#39;s Blog">
<meta property="og:description" content="Welcome to my Ark!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wind">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ultrahjr.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wind's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wind's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry. Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/05/10/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%892-12-hashing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%892-12-hashing/" class="post-title-link" itemprop="url">问题求解（二）2-12 hashing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 09:38:13" itemprop="dateCreated datePublished" datetime="2022-05-10T09:38:13+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 16:41:52" itemprop="dateModified" datetime="2022-05-11T16:41:52+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">算法与数学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lecture-Notes/" itemprop="url" rel="index"><span itemprop="name">Lecture Notes</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lecture-Notes/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>哈希表是一种有效的动态集合结构。</p>
<h2 id="11-1-直接寻址表"><a href="#11-1-直接寻址表" class="headerlink" title="11.1 直接寻址表"></a>11.1 直接寻址表</h2><p>当关键字的全域较小，且有条件：不存在两个元素的关键字相同，则我们可以通过直接寻址表（direct-address table）来实现直接寻址。本质相当于桶排序中，将元素的key值作为数组下标进行访问、存储、修改和删除的操作。详细操作与definition在TC P143，不多赘述。</p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise:"></a>Exercise:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11.1-1 无论从那种方式遍历整个直接寻址表都是可行的，但是时间复杂度上界均为O(m)。这是因为我们的key值分布是离散的，总存在需要遍历整个表的最坏对手策略。</span><br><span class="line">11.1-2 这里的位向量本身，可以看作一个状态压缩二进制数。设v[k]表示向量v的第k个基底的坐标，若v[k]=1则表示第k个元素在哈希表内，若v[k]=0则表示第k个元素不在哈希表内。那么，我们的INSERT,DELETE,SEARCH都是O(1)的时间复杂度。</span><br></pre></td></tr></table></figure>

<ul>
<li>当题目要求证明字典操作的运行时间为O(1)时，这里的字典操作通常指的就是INSERT,DELETE,SEARCH三种。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11.1-3 不大清楚当槽中存储的是链表时，如何分析时间复杂度，待定。</span><br><span class="line">11.1-4 待分析</span><br></pre></td></tr></table></figure>



<h2 id="11-2-哈希表"><a href="#11-2-哈希表" class="headerlink" title="11.2 哈希表"></a>11.2 哈希表</h2><p>  直接寻址技术的缺点是非常明显的：当我们key值的全域很大的时候，我们需要预先开一个大小为$|U|$ 的一张哈希表。而且由于实际存储的关键字集合$|K|$ 可能相比于$|U|$而言变得很小，这里开巨大的哈希表就会浪费巨量的空间资源。</p>
<p>  为了避免空间的浪费，我们通过构造一个映射哈希函数$h(x)$，可以将空间复杂度降为$\Theta(|K|)$，即：$h: U \rightarrow \lbrace 0,1,2,….m-1 \rbrace$ 这里就将$|U|$降为$|m|$了。</p>
<p>  同时，当我们的key值存在相同的情况时，就会出现冲突collision。一个简单的想法是，通过构造一个和数的哈希函数h，保证h尽可能地随机，从而将冲突地可能或者次数最小化。（当然，对于同一个键值key，其哈希函数的映射结果应当不变，依旧为h(k)）</p>
<p>我们有两种方法来解决冲突：其一为链接法（Chaining）、其二为开发寻址法（Open Addressing）</p>
<h3 id="链接法："><a href="#链接法：" class="headerlink" title="链接法："></a>链接法：</h3><p>  链接法的本质，是通过将哈希到同一个槽中的所有元素都放到一个链表中。当槽中带有的链表是非空的时候，槽内应当有一个指针，它指向存储所有哈希到j的元素的链表的表头；如果不存在这样的元素，则槽j中为NIL。</p>
<p>对于链接法实现的哈希表操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHAINED-HASH-INSERT(T,x)</span><br><span class="line">	insert x at the head of list T(h(x.key)) </span><br><span class="line">将元素x插入到哈希表T中的操作：只需要取出x的键值key，将其进行哈希处理得到对应映射到的槽标号，然后取出其链表，将元素x插入到这个链表的表头上。</span><br><span class="line">插入操作的最坏运行时间为O(1)，只需要计算哈希函数和插入链表即可。</span><br><span class="line">CHAINED-HASH-SEARCH(T,k)</span><br><span class="line">	search for an element with key k in list T[h(k)]</span><br><span class="line">CHAINED-HASH-DELETE(T,x)</span><br><span class="line">	delete x from the list T[h(x.key)]</span><br></pre></td></tr></table></figure>

<p>对于SEARCH操作，在对应的哈希函数结果的链表中搜索，是否存在键值为k的元素。对于删除操作，其复杂度在单链表情况下与SEARCH操作同阶，因为删除的时候需要先遍历链表T[h(x.key)]来找到前一个元素，然后再修改其后继节点。在双向链表情况下，复杂度为O(1)，因为我们传入的是元素x，所以不需要先在链表中搜索x。直接修改其前驱和后继节点即可。</p>
<p>我们接下来分析其性能。特别的，我们分析一下：要查找一个具有给定关键字的元素需要多长的时间。</p>
<p>  对于一个能存放n个元素、具有m个槽位的哈希表T，定义T的装载因子$\alpha &#x3D; \frac{n}{m}$，即一个链表的平均元素存放数目。</p>
<p>  首先，对于最坏情况，即所有的元素都被哈希映射到同一个槽上，这里的复杂度是$\Theta(n)$，n为链表的长度。当然，我们通过构造合理的哈希函数可以避免这种最坏的情况，且并不因为最坏复杂度很劣而忽视其平均效率的优势。</p>
<p>  定义：简单均匀哈希，我们假设，n个元素中任何一个关键字的元素都会被等可能地映射到m个槽的位置上，且与其他元素被哈希到什么位置上无关，成这个假设为简单均匀哈希。</p>
<p>  设$n_i$表示第i个槽对应的链表的长度，显然有：$n &#x3D; \sum_{i &#x3D; 0}^{m-1} n_i$，并且$n_j$的期望为：$E[n_j] &#x3D; n \times \frac{1}{m} &#x3D; \alpha$</p>
<p>我们不妨假设我们能够在O(1)的时间内计算出哈希值和访问槽链表。那么，当我们询问元素x时，查找的可能有两种：成功查找与不成功查找。下面的论证建立在简单均匀哈希的条件下：</p>
<p>一、对于不成功查找的情况</p>
<p>显然，我们从链表T[h(x.key)]的首元素遍历到尾元素，没有找到期望的元素x。那么，其期望时间就是查找到链表末尾的时间，而链表的期望长度已在上文给出，则期望时间为遍历链表和计算哈希值、访问槽链表常数时间之和为：$\Theta(1+\alpha)$</p>
<p>二、对于成功查找的情况</p>
<p>  我们假定要查找的元素是，表中存放的n个元素中的任何一个。且是等可能的，那么，每一次成功查找某个元素x的过程中，我们会遍历的元素就是x所在链表前面的每个元素加上x本身。而由于链表维护的过程中，所有x前面的元素，都是在x之后插入的。为了考察所检查的元素的期望数目，我们只需要计算在元素x之后，哈希到同一个槽链表的元素个数的期望值，再加1。然后再对n取平均。</p>
<p>  不妨设$x_i$表示插入表中的第i个元素，考察$x_i$的关键字$k_i &#x3D; x_i.key$，对关键字$k_i, k_j, i &lt; j$定义指示器随机变量$X_{ij}&#x3D; I\lbrace h(k_i) &#x3D; h(k_j) \rbrace$。我们的讨论基于简单均匀哈希，显然有：$Pr\lbrace h(k_i) &#x3D; h(k_j) \rbrace &#x3D; \frac{m}{m \times m} &#x3D; \frac{1}{m}$，那么应当有：$E[X_{ij}] &#x3D; \frac{1}{m}$。则，在一次成功的查找中，所检查元素的期望数为</p>
<p>$$<br>E[\frac{1}{n}\sum_{i &#x3D; 0}^{n - 1}(1 + \sum_{j &#x3D; i + 1}^{n - 1}X_{ij})] \ &#x3D; \frac{1}{n}E[\sum_{i &#x3D; 0}^{n - 1}(1 + \sum_{j &#x3D; i + 1}^{n - 1}X_{ij}) \<br>&#x3D;  \frac{1}{n}E[\sum_{i &#x3D; 0}^{n - 1}(1 + \sum_{j &#x3D; i + 1}^{n - 1}\frac{1}{m})] \<br>&#x3D; \frac{1}{n}(n + \sum_{i &#x3D; 0}^{n - 1}\sum_{j &#x3D; i + 1}^{n - 1}\frac{1}{m}) \<br>&#x3D; 1 +\frac{1}{nm}\sum_{i &#x3D; 0}^{n - 1}\sum_{j &#x3D; i + 1}^{n - 1}1  \<br>&#x3D; 1 + \frac{1}{nm}\sum_{i &#x3D; 0}^{n - 1}(n -  i) \<br>&#x3D;  1 + \frac{1}{nm}(n^2 - \frac{n(n-1)}{2}) \<br>&#x3D;  1 + \frac{n}{m} - \frac{n-1}{2m} \<br>&#x3D; \Theta(1 + \alpha)<br>$$</p>
<p>综上所述，<strong>一次查找的时间复杂度为$\Theta(1 + \alpha)$，而当哈希表中的槽数至少与表中成正比的时候，则有$n &#x3D; O(m)$，从而有：$\alpha &#x3D; \frac{n}{m} &#x3D; \frac{O(m)}{m} &#x3D; O(1)$。所以，查找操作平均上需要常数时间。而当链表采用双向连接时，插入操作在最坏情况下需要O(1)时间，删除也需要O(1)时间，所以平均情况下，可以在O(1)时间内完成所有的字典操作。</strong></p>
<h3 id="11-3-哈希函数"><a href="#11-3-哈希函数" class="headerlink" title="11.3 哈希函数"></a>11.3 哈希函数</h3><p>算法导论上给出了两种构造哈希函数的方法：分别是乘法哈希和除法哈希，具体内容见TC P147即可。</p>
<p>还有一种哈希方法：全域哈希，这是为了防止一个恶意的对手通过构造关键字序列来针对选择的哈希函数。这样构造的关键字会将所有的元素都哈希映射到同一个槽上。为了应对这种策略，唯一有效的改进方法就是：随机地选择哈希函数，使之独立于要存储的关键字，这种方法就称为全域哈希。</p>
<p><strong>设A表示一组哈希函数，它将给定的关键字全域$|U|$哈希映射到$\lbrace 0,1,…m-1\rbrace$上，这样的一个函数族称之为全域的（universal），如果对于每一对不同的关键字$i, j$，满足$h(i) &#x3D; h(j) $的哈希函数$h \in A$的个数不超过$\frac{|A|}{m}$，也就是说，我们随机地从函数族A中选取一个哈希函数h，它导致关键字i和j发生冲突的概率为$\frac{1}{m}$ ，而这个概率也恰好是从上述集合中随机选择$h(k), h(l)$时发生冲突的概率。</strong></p>
<p>定理11.3表明，全域哈希函数类的平均性态是比较好的。</p>
<p><strong>定理11.3：如果h选自一组全域哈希函数，将n个关键字哈希到一个大小为m的表T中，并且用链接法解决冲突。如果关键字k不在表中，则k被哈希到其中的链表的期望长度至多为$E[n_{h(k)}] &#x3D; \alpha &#x3D; \frac{n}{m}$ , 如果关键字k在表中，则包含关键字k的链表的期望长度至多为$\alpha + 1$</strong></p>
<p>证明：我们首先注意到，这里的期望是与哈希函数的选择、关键字的分布是无关的，因为我们的h是选自一组全域哈希函数。那么根据全域哈希假设，可知对于任意两个关键字$k, l$，概率$Pr\lbrace h(k) &#x3D; h(l) \rbrace \leq \frac{1}{m}$。那么，定义指示器随机变量$X_{kl} &#x3D; I\lbrace h(k) &#x3D; h(l) \rbrace$， 则$E[X_{kl}] \leq \frac{1}{m}$。接下来，设$Y_k$表示和关键字k哈希到同一槽处的元素个数，则有：<br>$$<br>Y_k &#x3D; \sum_{l \in T, l \ne k}X_{kl}\<br>E[Y_k] &#x3D; E[\sum_{l \in T, l \ne k}X_{kl}] &#x3D; \sum_{l \in T, l \ne k}E[X_{kl}]\<br>$$<br>接下来，对k在哈希表中的位置进行分类讨论：</p>
<ul>
<li>若关键字k之前并没有出现在链表中，则关键字k对应的哈希链表长度$n_{h(k)} &#x3D; Y_k$，且对于集合$|\lbrace l \in T, l \ne k \rbrace| &#x3D; n$，那么，有</li>
</ul>
<p>$$<br>length &#x3D; E[Y_k] &#x3D; \sum_{l \in T, l \ne k}E[X_{kl}] &#x3D; \sum_{l &#x3D; 1}^{n} E[X_{kl}] \leq \frac{n}{m} &#x3D; \alpha &#x3D; O(\alpha + 1)\<br>$$</p>
<ul>
<li>若关键字k之前出现在链表中，则关键字k对应的哈希链表长度为$n_{h(k)} &#x3D; Y_k + 1$，且对于集合$|\lbrace l \in T, l \ne k \rbrace| &#x3D; n - 1$所以有：</li>
</ul>
<p>$$<br>length &#x3D; 1 + E[Y_k] &#x3D; 1 + \sum_{l \in T, l \ne k}E[X_{kl}] &#x3D; 1 + \sum_{l &#x3D; 1, l\ne k}^{n} E[X_{kl}] \leq 1 +  \frac{n-1}{m} &#x3D; 1 + \alpha - \frac{1}{m} &#x3D; O(1 + \alpha)\<br>$$</p>
<p>所以综上所述，关键字在哈希表中对应槽的链表期望长度为$O(1 + \alpha)$，而当$\alpha$与n成正比时，这个平均的时间开销是O(1)的！所以，上述分析就证明了，全域哈希函数在槽数与全域规模是线性关系的时候，其平均性能是很优秀的。</p>
<p><strong>推论11.4：对于一个具有m个槽位且初始时为空的表，利用全域哈希法和链接法解决冲突，需要$\Theta(n)$的期望时间来处理任何包含了n个INSERT,SEARCH和DELETE的操作序列，其中该序列包含了$O(m)$个INSERT操作。</strong></p>
<p>证明：首先，由于我们INSERT的次数为$O(m)$，因此，总的元素个数$n &#x3D; O(m)$，故有$\alpha &#x3D; \frac{n}{m} &#x3D; \frac{O(m)}{m} &#x3D; O(1)$。根据定理11.3，每一个SEARCH的实际时间是和$\alpha$成线性关系的，所以时间开销为$O(1)$。然后，由于INSERT操作和DELETE操作都只需要常数时间，根据期望的线性性质可知：总的n个操作的序列总的时间开销为$O(n)$。然后由于每个操作所用时间为：$\Omega(1)$，所以$\Theta(n)$的界成立。</p>
<p><strong>设计一个全域哈希函数类：也就是设计这样的哈希函数族，满足从中随机抽取一个哈希函数h，其对于关键字全域$|U|$中任意两个元素k,l，发生冲突的概率不超过$\frac{1}{m}$。这里的m是我们提供的槽的数目</strong></p>
<p>选择一个足够大的素数p。使得每一个可能的关键字k都落在0 - p-1的范围内。（包括0和p-1）。设集合$Z_p$代表集合$\lbrace 0,1,…..p-1\rbrace$，$Z_p^*$表示集合$\lbrace 1, … p-1 \rbrace$ 。由于p是一个素数，根据第31章给出的求解模数方程的方法可以求解之。由于我们假定关键字的全域大于哈希表中的槽数，则有$p &gt; m$。</p>
<p>现在，对于$\forall a \in Z_p^*, b \in Z_p$，定义哈希函数$h_{ab} &#x3D; ((ak + b) modp) mod m$，这样构成的函数族A就是：$A &#x3D; \lbrace h_{ab},a \in Z_p^*, b \in Z_p \rbrace$。注意，这里a的选择有p-1中，需要将0排除在外，因为若选择到了0，则线性变换进行的就是一个零变换，会将输入的关键字k的效果抹去。而b有p中选择，故这个函数族的势为：$|A| &#x3D; p(p-1)$</p>
<p>上述方法定义的哈希函数具有一个良好的性质，即输出范围的大小m是任意的，不必是一个素数。</p>
<p><strong>定理11.5 上述方法定义的哈希函数族A是全域的。</strong></p>
<p>我们只需要证明，对于全域U中任意的两个不同的关键字k,l。在上述哈希函数族中随机选择一个哈希函数，两者发生冲突的概率不超过$\frac{1}{m}$</p>
<p>首先，考察两者在模p意义下的部分数r，s<br>$$<br>r &#x3D; (ak + b)mod p \<br>s &#x3D; (al + b)mod p<br>$$<br>然后，两边在模p的意义下做差有：$r-s \equiv a(k-l)modp$，由于a对p取模非0，k-l对p取模也非0，则两者乘积后取模也非0，则必有r、s不等。所以，在模p的维度上，并不会发生冲突。</p>
<p>这一点也是很好理解的，因为单单做到这一步，其实是做了上面的直接寻址（浪费空间）而这样做并不会发生冲突。之后我们再对m取模，就会产生冲突了。</p>
<p>此外，我们的数对(a,b)一共有p(p-1)种选择，如何解释这点？因为我们可以根据r和s反解出a、b的值。也即，这里的每一对数对(a,b)和p(p-1)个数对(r,s)之间存在一个一一对应的关系。于是，对于任意给定的输入对k和l，如果均匀地随机选择(a,b)，则结果数对(r,s)就等可能地位任何不同的数值对。所以，当r和s为随机选择的不同的值的时候（注意，我们这里的，r和s随机选择不同的值，其实就是在哈希函数族中随机取了某个哈希函数，使得r和s有对应的值，全域里面随机哈希函数就体现在这里），不同的关键字k和l发生冲突的概率，等于$r \equiv s (modm)$的概率。而，我们根据同余类的知识可知，满足两者有相同余数，且在0-p-1范围内的元素个数为：$\lceil \frac{p}{m} \rceil - 1 \leq \frac{p + m - 1}{m} - 1 &#x3D; \frac{p-1}{m}$。则，我们可以得出任意的两个元素发生冲突的概率为：$Pr\lbrace h(k) &#x3D; h(l)\rbrace &#x3D; \frac{\lceil \frac{p}{m} \rceil - 1 }{p - 1} \leq \frac{1}{m}$，所以，全域条件得证。</p>
<h3 id="11-4-开放寻址法"><a href="#11-4-开放寻址法" class="headerlink" title="11.4 开放寻址法"></a>11.4 开放寻址法</h3><p>开放寻址法也是解决冲突的一种手段。但是，这种方法需要限制装载因子$\alpha \leq 1$。否则，这个哈希表就可能被填满，以至于不能插入任何新的元素。</p>
<p>当查找某个元素的时候，需要系统地检查所有地表项，直到找到所需的元素。或者最终查明这个元素不在表中。</p>
<p>为了使用开放寻址法插入一个元素，我们需要连续地检查哈希表。这个过程称为探查。直到找到一个空槽来放置待插入的关键字为止。检查的顺序不一定是0，1，….m-1（这种顺序为$\Theta(n)$）。而是要依赖待插入的关键字。</p>
<p>为了确定要探查那些槽，我们将哈希函数加以扩充，使之包含探查号以作为其第二个输入参数。这样，哈希函数就变为：$h: U \times \lbrace 0, 1, 2, … m-1\rbrace \rightarrow \lbrace 0, 1, 2, … m-1\rbrace$。对每一个关键字k，使用开放寻址法的探查序列：$&lt;h(k,0), h(k, 1), ….h(k, m-1)&gt;$，这个序列是$\lbrace 0, 1, …m-1\rbrace$的一个排列。</p>
<p>对于INSERT和SEARCH操作，我们只需要遍历上面这个探查序列即可。对于INSERT，找到NIL的槽就可进行存储；而SEARCH操作遇到NIL或者已满，就代表没有找到。</p>
<p>对于DELETE操作，一般不用开放寻址法来考察。直接对T[k]置为NIL会导致能遍历到k处的，后续插入节点的丢失。无法遍历到他们了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/04/16/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/16/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">面向对象/OOP/C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 20:36:16" itemprop="dateCreated datePublished" datetime="2022-04-16T20:36:16+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 09:51:25" itemprop="dateModified" datetime="2022-05-10T09:51:25+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/" itemprop="url" rel="index"><span itemprop="name">Computer Technology</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">面向对象程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高级程序设计部分"><a href="#高级程序设计部分" class="headerlink" title="高级程序设计部分"></a>高级程序设计部分</h1><p>静态成员函数：只能访问类的静态成员，可以通过对象来访问，也可以直接通过类来访问。</p>
<p>静态数据成员，对于该类的所有对象来说，都只有一个拷贝，可以理解为相同类的共有的数据成员。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">扩展生存期</span><br><span class="line">局部变量，由自动生存期-&gt;静态生存期</span><br><span class="line">限制作用域</span><br><span class="line">全局变量 全局作用域-&gt;文件作用域</span><br><span class="line">唯一性</span><br><span class="line">类的成员 属于单个对象-&gt;属于整个类（所有对象以及没有对象）</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>为了提高在类的外部对类的数据成员的访问效率，在C++中，可以指定一个与类密切相关、又不适合作为该类成员的程序实体。（某些全局函数、某些其他类或者某些其他类的某些成员函数）可以直接访问该类的private和protected成员。这些程序实体称为该类的友元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"> friend void func();//友元函数</span><br><span class="line"> friend class B;//友元类</span><br><span class="line"> friend void C::f();//友元类成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具有不对称性、不传递性，只要没有具体的指出A是B的友元，我们不认为A是B的友元。友元是数据保护和数据访问效率之间的一种折中方案。</p>
<h2 id="继承、派生类"><a href="#继承、派生类" class="headerlink" title="继承、派生类"></a>继承、派生类</h2><h3 id="基类与派生类"><a href="#基类与派生类" class="headerlink" title="基类与派生类"></a>基类与派生类</h3><p>在继承关系中存在两个类：基类（或称父类）和派生类（或称子类）。派生类拥有基类的所有成员，并可以：</p>
<p>定义新的成员，</p>
<p>对基类的一些成员（成员函数）进行重定义。</p>
<p>继承分为：单继承和多继承</p>
<p>单继承：一个类只有一个直接基类</p>
<p>多继承：一个类又多个直接基类</p>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>在定义单继承时，派生类只能由一个直接基类，其定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;:[&lt;继承方式&gt;]&lt;基类名&gt;</span><br><span class="line">&#123; &lt;成员说明表&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员说明表是在派生类中新定义的成员，其中包括对基类成员的重定义。</p>
<p>继承方式用于指出从基类继承来的成员在派生类中对外的访问控制。</p>
<p>派生类除了拥有新定义的成员外，还拥有基类的所有成员（基类的构造函数、赋值操作符重载函数、析构函数除外）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	public:</span><br><span class="line">	void f();</span><br><span class="line">	void g();</span><br><span class="line">&#125;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">	int z;//新成员</span><br><span class="line">	public:</span><br><span class="line">	void h();//新成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义派生类的时候一定要见到基类的定义。如果没有，编译程序不知道基类中是否有函数g以及函数g的原型。如果直接用B声明新的变量，则不行，因为编译无法确定b所需内存空间的大小。</p>
<p>如果在派生类中没有显式说明，基类的友元不是派生类的友元；如果基类是另一个类的友元，而该类没有显式说明，则派生类也不是该类的友元。</p>
<p>C++中派生类不能直接访问基类的私有成员!</p>
<p>这就带来了一个问题：在派生类中定义新的成员函数或对基类已有成员变量重定义的时候，往往需要直接访问基类的一些private成员。否则新的功能无法实现。</p>
<p>但是，类的private成员是不允许外界使用的（数据封装）！</p>
<p>这样就带来了继承与封装的矛盾！</p>
<p>有了继承及之后，一个类的成员有了两种被外界应用的场合：</p>
<ul>
<li>通过类的对象（实例）使用</li>
<li>在派生类中使用</li>
</ul>
<h3 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h3><p>这是另一种类成员访问控制，用protected说明的成员不能通过对象使用，但可以在派生类中使用。这样就缓解了封装与继承的矛盾。</p>
<p>所以C++类对外提供两种接口：</p>
<ul>
<li>public:对象的使用者（类的实例用户）</li>
<li>public+protected：派生类</li>
</ul>
<h2 id="类中的标识符作用域"><a href="#类中的标识符作用域" class="headerlink" title="类中的标识符作用域"></a>类中的标识符作用域</h2><p>对基类而言，派生类成员的标识符作用域是嵌套在基类作用域之中的。</p>
<p>如果派生类中定义了与基类同名的成员，则基类的同名成员会被隐式隐藏。不过我们可以通过限制作用域来提供声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">int x,int y;</span><br><span class="line">public:</span><br><span class="line">void f();</span><br><span class="line">&#125;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">	int z;</span><br><span class="line">	public:</span><br><span class="line">	void f();</span><br><span class="line">	void h()</span><br><span class="line">	&#123;</span><br><span class="line">		f();//这里调用的是B作用域下的函数B::f();</span><br><span class="line">		A::f();//这里调用的是A类中的函数</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使参数不同，也需要上述操作！</p>
<h3 id="派生类对象的创建"><a href="#派生类对象的创建" class="headerlink" title="派生类对象的创建"></a>派生类对象的创建</h3><p>派生类对象的创建过程，需要同时调用基类和派生类的构造函数。继承自基类的成员变量通过基类的构造函数构造，新定义或重载的变量通过派生类的构造函数创建。注意，在使用非默认基类构造函数的时候，需要指定相应的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A //A为基类</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		int x, y;</span><br><span class="line">	A()&#123;x = 1; y = 0;&#125;</span><br><span class="line">	A(int a,int b):x(a),y(b)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">	public: </span><br><span class="line">		int z;</span><br><span class="line">	B()&#123;z = 1;&#125;</span><br><span class="line">	B(int i)&#123;z = i;&#125;</span><br><span class="line">	B(int i, int j, int k):A(i,j)&#123;z = k;&#125;</span><br><span class="line">&#125;</span><br><span class="line">B b1();//调用A::A()和B::B(),x = 1,y = 0, z = 1</span><br><span class="line">B.b2(3);//调用A::A()和B::B(3),x = 1,y = 0,z = 3</span><br><span class="line">B.b3(4,5,6);//调用A::A(4,5)和B::B(6),x=4,y=5,z=6</span><br></pre></td></tr></table></figure>

<h3 id="派生类对象的析构"><a href="#派生类对象的析构" class="headerlink" title="派生类对象的析构"></a>派生类对象的析构</h3><p>派生类对象的析构由基类和派生类共同完成：从基类继承的数据成员由基类的析构函数析构；派生类的数据成员由派生类的析构函数析构。</p>
<p>当创建派生类的对象时，先执行基类的构造函数，再执行派生类构造函数。</p>
<p>当析构派生类的对象时，先执行派生类的析构函数，再执行基类析构函数。</p>
<p>如类D既有基类B、又有成员对象类M，则在创建D类对象时，</p>
<p>构造函数的执行次序为：B-&gt;M-&gt;D</p>
<p>当D类的对象消亡时，析构函数的执行次序为：D-&gt;M-&gt;B</p>
<p>派生类拷贝构造函数：派生类的隐式拷贝构造函数（由编译程序提供）将会调用基类的拷贝构造函数。派生类自定义的拷贝构造函数在默认情况下则调用基类的默认构造函数。需要时，可在派生类自定义拷贝构造函数的“成员初始化表”中显式地指出调用基类的拷贝构造函数。 </p>
<h2 id="框架代码导读"><a href="#框架代码导读" class="headerlink" title="框架代码导读"></a>框架代码导读</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>的<span class="keyword">final</span>关键字，是用来防止非必要的继承发生的，这样可以行之有效地防止内存的泄露。</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;的作用是使函数适用于不同的输入类型。</span><br><span class="line">然后下面的函数接<span class="keyword">auto</span>，<span class="keyword">auto</span>可以理解成，</span><br><span class="line">    <span class="keyword">auto</span>被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存</span><br></pre></td></tr></table></figure>

<p>游戏对象GameObject类：玩家操作的任务、地图地砖、可炸毁的箱子…</p>
<p>游戏场景GameScene类：负责管理调度所有的游戏对象</p>
<p>组件类Component：对应游戏对象的一个属性，例如显示贴图、受到键盘控制、可被受到伤害等。</p>
<p>显示组件均为Transform，用于游戏对象的绘制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//新建一个游戏对象：</span><br><span class="line">GameObject * Player1 = new GameObject();</span><br><span class="line">//加入场景</span><br><span class="line">gameScene-&gt;attachGameObject(Player1);</span><br><span class="line">//运行时添加游戏对象</span><br><span class="line">Component::attachGameObject</span><br><span class="line">//运行时销毁游戏对象</span><br><span class="line">Component::destroy</span><br><span class="line">//绘制，框架通过显示组件Transform管理绘制</span><br><span class="line">//为每一个需要绘制的游戏对象挂载Transform()</span><br><span class="line">auto transform = new Transform();</span><br><span class="line">obj-&gt;addComponent(transform);</span><br><span class="line">//getComponent获取其他组件的指针</span><br><span class="line">//可在onAttach或onFirstUpdate中缓存其他组件的指针</span><br><span class="line">//游戏对象是组件的集合</span><br><span class="line">//将游戏对象拆分成组件的集合，避免大而全的类</span><br><span class="line">显示玩家对应的照片Transform</span><br><span class="line">受到地形限制Physics</span><br><span class="line">键盘UserController</span><br><span class="line">可以受到伤害Hittable</span><br><span class="line"></span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/04/11/Learning-notes-on-QT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/11/Learning-notes-on-QT/" class="post-title-link" itemprop="url">Learning Notes On Qt/项目研究笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-11 19:18:47" itemprop="dateCreated datePublished" datetime="2022-04-11T19:18:47+08:00">2022-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 09:52:00" itemprop="dateModified" datetime="2022-05-10T09:52:00+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/" itemprop="url" rel="index"><span itemprop="name">Computer Technology</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/QT/" itemprop="url" rel="index"><span itemprop="name">QT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、一些历史-x2F-杂七杂八"><a href="#一、一些历史-x2F-杂七杂八" class="headerlink" title="一、一些历史&#x2F;杂七杂八"></a>一、一些历史&#x2F;杂七杂八</h2><p>QT是一个跨平台的C++图形用户界面应用程序框架</p>
<p>Linux的操作界面是由QT编写的</p>
<p>支持Windows、Unix、Embedded（嵌入式）、Max Os</p>
<p>vs的默认格式是GB2312的，Mingw的默认格式是UTF8，这就解释了cpp文件在vs和dev cpp下分别打开为什么会出现中文的乱码</p>
<h2 id="二、Qt基础内容"><a href="#二、Qt基础内容" class="headerlink" title="二、Qt基础内容"></a>二、Qt基础内容</h2><p>QApplication是 包含一个应用程序类的头文件</p>
<p>main函数，是程序的入口。</p>
<p>argc命令行变量的数量， argv命令行变量的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">myWidget w;<span class="comment">//创建一个窗口对象w， 其父类为Qwidget</span></span><br><span class="line"><span class="comment">//对于窗口对象w，调用一个show方法</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">exec</span>();<span class="comment">//让代码阻塞到这行来，不会往下运行了，会时刻捕捉当前的用户信息</span></span><br></pre></td></tr></table></figure>

<p>a是应用程序对象，在Qt中，应用程序对象，有且仅有一个。</p>
<p>窗口对象默认不会显示，必须调用show方法来显示窗口。通过show的方式来调用函数进行展示</p>
<p>让应用程序对象进入消息循环，可以理解为一个死循环。</p>
<p>这里的a.exec()相当于让整个程序无限循环，时刻捕捉用户键入的窗口信息。也就是让代码阻塞到这里。</p>
<h3 id="pro文件的解释"><a href="#pro文件的解释" class="headerlink" title=".pro文件的解释"></a>.pro文件的解释</h3><p>.pro文件就是工程文件project，它是qmake自动生成的用于生产makefile的配置文件，对于一个一般的.pro文件，解读如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QT += core gui <span class="comment">//QT包含的模块，一个叫核心模块core，一个叫Gui，用户图形界面</span></span><br><span class="line"><span class="comment">//Qt还有很多其他的模块，如Qt Network/SQL/...</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets.<span class="comment">//大于4版本以上，包含QT widget模块（这一句的意思是，让程序的兼容性更强，即使是4以下的也可以跑所需要的代码）</span></span><br><span class="line">TARGET = <span class="number">01</span>_FirstProject <span class="comment">//目标程序的名称，会以此来命名我们新生成的exe文件的名称</span></span><br><span class="line">TEMPLATE = app <span class="comment">//模板，相当于当前创建的应用程序的模板</span></span><br><span class="line">SOURCES += main.cpp \ <span class="comment">//这里是一系列的源文件</span></span><br><span class="line">    		mywidget.cpp\</span><br><span class="line"> </span><br><span class="line">HEADERS += mywidget.h <span class="comment">//头文件部分</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注释：从<span class="string">&quot;#&quot;</span>开始，到这一行结束。</span><br><span class="line">模板变量告诉qmake为这个应用程序生成那种makefile，下面是可供使用的选择：</span><br><span class="line">    TEMPLATE = app</span><br><span class="line">app 建立一个应用程序的makefile，这是默认值，所以如果模板没有被认定，这个将被使用。</span><br><span class="line">lib 建立一个库的makefile</span><br><span class="line">vcapp 建立一个应用程序的VisualStudio项目文件</span><br><span class="line">vclib 建立一个库的VisualStudio的项目文件</span><br><span class="line">subdirs 这是一个特殊的模板，它可以创建一个能够进入特定目录斌且为一个项目文件生成makefile并且为它调用make的makefile</span><br></pre></td></tr></table></figure>

<h3 id="标准的Qt文件内容"><a href="#标准的Qt文件内容" class="headerlink" title="标准的Qt文件内容"></a>标准的Qt文件内容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidegt&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//Q_OBJECT宏，这是允许类中使用信号和槽的机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">快捷键：</span><br><span class="line">ctrl + / 注释</span><br><span class="line">ctrl + r 运行</span><br><span class="line">ctrl + b 编译</span><br><span class="line">ctrl + 滚轮 可以进行字体的放大和缩小</span><br><span class="line">ctrl + f 查找</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现一个Qpushbutton"><a href="#实现一个Qpushbutton" class="headerlink" title="实现一个Qpushbutton"></a>实现一个Qpushbutton</h3><p>在QT中实现一个按钮</p>
<p>Header: #include <QPushButton></p>
<p>qmake: QT +&#x3D; widgets</p>
<p>Inherite: 父类，是QAbstractButton</p>
<p>Inherited by: QCommandLinkButton 这是在描述一系列子类<br>同名的一些公共函数的一些代码…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建一个按钮</span><br><span class="line">myWidget:mywidget(QWidget *parent)</span><br><span class="line">	: Qwidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">QPushButton * btn = new QPushButton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是显示不出来的，因为窗口是默认不显示的。而其为一个类，可以通过调用show函数（来自QObject祖宗类）来让它显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个按钮</span><br><span class="line">myWidget:mywidget(QWidget *parent)</span><br><span class="line">	: Qwidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">QPushButton * btn = new QPushButton;</span><br><span class="line">btn-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>show默认的是用一个顶层的方式来弹出窗口控件的显示的，这样显示的是一个独立的窗口，而不能使btn按钮控件显示在我们创建的窗口之中。</p>
<p>我们要让btn对象，依赖在myWidget窗口中。所以，对于btn要设置父亲！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建一个按钮</span><br><span class="line">myWidget:mywidget(QWidget *parent)</span><br><span class="line">	: Qwidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">QPushButton * btn = new QPushButton;</span><br><span class="line">btn-&gt;show();</span><br><span class="line">btn-&gt;setParent(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，将btn的父亲设置为当前的这个mywidget类，这样就能将按钮显示到当前的页面上了。</p>
<p>然后，我们还可以对按钮添加显示的文本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按钮</span></span><br><span class="line">myWidget:<span class="built_in">mywidget</span>(QWidget *parent)</span><br><span class="line">	: <span class="built_in">Qwidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">QPushButton * btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的字符串隐式类型转换为Qstring了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建第一个按钮</span><br><span class="line">myWidget:mywidget(QWidget *parent)</span><br><span class="line">	: Qwidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">QPushButton * btn = new QPushButton;</span><br><span class="line">btn-&gt;show();</span><br><span class="line">btn-&gt;setParent(this);</span><br><span class="line">btn-&gt;setText(&quot;第一个按钮&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们还有一种创建按钮的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn2 = new QPushButton(&quot;第二个按钮&quot;, this);</span><br></pre></td></tr></table></figure>

<p>这样就同时指定了按钮上方的文本内容和其父亲，不过这样显示出来的，show函数是根据控件的大小来完成窗口绘制的，要使这个窗口是正常大小，我们需要调用resize()函数</p>
<p>其有两个参数w和h，w是width, h是height</p>
<p>如果我们此时同时使用两个按钮，两个就重叠了，可以使用如下操作进行按钮的移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//移动btn2按钮</span><br><span class="line">btn2-&gt;move(10, 100);//其坐标变为(10,100)</span><br></pre></td></tr></table></figure>

<p>设置窗口标题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setwindowtitle(&quot;第一个窗口&quot;);</span><br></pre></td></tr></table></figure>

<p>这样我们生成的窗口就会被命名为“第一个窗口”</p>
<p>设置固定窗口大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setFixedSize(600, 400);</span><br></pre></td></tr></table></figure>

<p>这样就无法进行缩放了</p>
<p>注意，我们上述声明的按钮在函数结束的时候是会结束的，不需要人为delete</p>
<h3 id="对象模型（对象树）"><a href="#对象模型（对象树）" class="headerlink" title="对象模型（对象树）"></a>对象模型（对象树）</h3><p>在QT中创建对象的时候会提供一个Parent对象指针，下面来解释这个Parent到底是干什么的。</p>
<ul>
<li>QObject是以对象树的形式组织起来的。</li>
</ul>
<p>当你创建一个Object对象时，会看到QObject的析构函数接受一个QObject指针作为参数，这个参数就是parent，也就是父对象指针。</p>
<p>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObjject对象会自动添加到其父对象的children()列表。</p>
<ul>
<li>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类）</li>
</ul>
<p>这种机制在GUI程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除，这是合理的。</p>
<ul>
<li>QWidget是能够在屏幕上显示的一切组件的父类。</li>
<li>QQWidget继承自QObject，因此也继承了这种对象树的关系。一个孩子自动地称为父组件的一个子组件。因此，它会显示在父组件的坐标系统里。被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</li>
</ul>
<p>打印字符</p>
<p>调用#include <QDebug>库，然后再对应的位置：qDebug () &lt;&lt; “析构调用” &lt;&lt; …</p>
<p>在对象树结构的析构下，它会类似进行一个广度优先搜索的析构方式。会遍历整颗被析构的对象树，并将树上的节点逐一释放。</p>
<p>当创建的对象在堆区的时候，如果指定的父亲是QObject派生下来的类，或者QObject的子类派生下来的类，可以不用管理释放的操作，因为它会将对象放到对象树中，完成逐级析构。</p>
<p>对象树的机制，一定程度下简化了内存回收的机制。</p>
<h2 id="QT的窗口坐标体系"><a href="#QT的窗口坐标体系" class="headerlink" title="QT的窗口坐标体系"></a>QT的窗口坐标体系</h2><p>以左上角为原点（0,0）,X向右增加，Y向下增加。对于嵌套窗口，其坐标是相对于父窗口而言的。</p>
<h2 id="三、信号与槽"><a href="#三、信号与槽" class="headerlink" title="三、信号与槽"></a>三、信号与槽</h2><h3 id="连接函数和槽函数的基本写法"><a href="#连接函数和槽函数的基本写法" class="headerlink" title="连接函数和槽函数的基本写法"></a>连接函数和槽函数的基本写法</h3><p>先提供一个案例：对于我们上述生成的按钮，点击后是没有任何作用的。现在，我们提供一个需求：点击我的按钮，我们就能够将窗口关掉。</p>
<p>那么，要完成上述需求，我们给出如下连贯的定义与操作：按钮-点击-窗口-关闭窗口。</p>
<p>上述过程可以抽象为，一个Connect(信号的发送者，发送的具体信号，信号的接收者，信号的处理（槽）)</p>
<p>其实，信号和槽中的槽，就是一个处理信号的槽函数。一般来说，信号的处理就是槽函数给出的处理方式。</p>
<p>信号和槽的优点：松散耦合，指信号的发送端和接收端本身是没有什么关联的，通过一个Connect函数连接，将两端耦合在一起。感性认识上，按钮点击不一定会发出信号，因为完全可以点击一些别的按钮。而窗口的关闭也并不仅仅依赖于唯一的处理方式，而可以有其他的关闭窗口的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//参数1 信号的发送者 参数2 发送的信号(signal, 存放的是函数的地址， 以&amp; + 类名 + ::信号名， 参数3 信号的接收者 参数4 槽函数：找到这个函数的地址</span><br><span class="line">connect( mybtn , &amp;QPushButton::clicked , this , &amp;QWidget::close ) ;  </span><br></pre></td></tr></table></figure>

<p>根据帮助文档，可以去尝试着找部分对象的信号出来。当然，不一定能直接在当前类的体系下找到，那么相应的signal可能就存在于其父类、爷爷类的内部了。可以这样去寻找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cilcked()</span><br><span class="line">press() //按下</span><br><span class="line">release() //释放</span><br><span class="line">toggled() //切换</span><br></pre></td></tr></table></figure>

<p>这就实现了一个Connect的功能！这就是连接函数的用法。接下来介绍的是Connect的四个参数。</p>
<p>注意：找函数的时候，一定要装入函数的地址！</p>
<h3 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h3><p>不属于任何部分的话，可以将其放到基类下QObject。</p>
<p>我们模拟如下的过程：写一个老师类和学生类，下课后，老师发出一个信号，饿了。接收者为学生，执行动作（槽函数）为请客吃饭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，在QT中新生成一个类的同时，除了public、private之外，还会要求我们写signals和public slots，这是在要求我们自定义信号和槽的内容，我们可以根据需求实现上述功能</span></span><br><span class="line"><span class="comment">//自定义信号，写到signals下，返回值是void，信号的头文件只需要声明，不需要写实现（连在cpp中都不需要），另外，这个信号是可以有参数的，也可以重载。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Teacher</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//槽函数的返回值也是void，是需要声明，也需要在cpp中实现的。</span></span><br><span class="line">    <span class="comment">//可以有参数，可以发生重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">()</span></span>;<span class="comment">//做了声明，那么就在cpp上实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，slot槽函数可以写到public或public slots下。（早期只能写到后者）</p>
<p>而如果我们写为如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(zt, &amp;Teacher::hungry , st , &amp;Student::treat);</span><br></pre></td></tr></table></figure>

<p>最后是没有显示的，因为，这个hungry的信号并不会发生！可以理解为，没有点击按钮，何来将窗口页面关闭的功能呢？</p>
<p>所以，此时可以加一个函数，这个函数的功能是，调用之后就会触发老师饿了的信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Widget::ClassIsOver()</span><br><span class="line">&#123;</span><br><span class="line">	emit zt-&gt;hungry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，即使完成了上述代码，也不能打印出“请老师吃饭”的信号，因为，需要在连接之后再调用才能有所反应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;zt = new Teacher(this);</span><br><span class="line">this-&gt;st = new Student(this);</span><br><span class="line">connect(this-&gt;zt, &amp;Teacher::hungry , this-&gt;st, &amp;Student::treat);</span><br><span class="line">ClassIsOver();</span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<p>我们自定义的信号必须写在signal下。所有的信号函数返回值都必须是void。可以有参数可以无参数，只需要声明，不能在cpp中实现。</p>
<p>槽函数需要在.h文件中声明，也需要在cpp中实现。（需要处理后续的操作嘛）</p>
<p>在Widget.cpp中，创建了老师也创建了学生，之后再让这两者连接一下，调用下课函数，触发饿了信号，然后就能看到“请老师吃饭”这一信号了。</p>
<p>注意，触发自己定义的信号，可以用emit来实现！</p>
<h3 id="自定义信号和槽的重载"><a href="#自定义信号和槽的重载" class="headerlink" title="自定义信号和槽的重载"></a>自定义信号和槽的重载</h3><p>void hungry(QString foodName);</p>
<p>这里在信号&#x2F;槽的函数声明中可以加上字符串参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Student::treat(QString foodName)</span><br><span class="line">&#123;</span><br><span class="line">	QDebug() &lt;&lt; &quot;请老师吃饭， 老师要吃&quot; &lt;&lt; foodName ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于发出信号的函数，可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void WIdget::ClassIsOver()</span><br><span class="line">&#123;</span><br><span class="line">	emit zt-&gt;hungry(&quot;宫保鸡丁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于连接函数，可以改写为：</p>
<p>首先，指针可以指向函数的地址，我们需要的是函数的地址，所以可以声明一个函数指针来指向函数的地址。</p>
<p>注：函数指针的声明方式为：  函数的返回值类型 (*函数名) (函数的具体参数格式)</p>
<p>例：in (*p) (int, int)，这里声明的函数指针，就是指向了一个返回值为int类型的函数，且这个函数的参数是两个int类型的参数。</p>
<p>当我们在声明一个成员函数的函数地址的时候，还需要加上这个函数的作用域。我们需要告诉指针，你所指向的这个函数是在某个特定作用域下的函数！这样这个函数指针才能识别这个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (Teacher:: *teacherSignal) (QString) = &amp;teacher::hungry;</span><br><span class="line"><span class="built_in">void</span> (STudent:: *studentslot) (QString) = %student::treat;</span><br><span class="line"><span class="built_in">connect</span>(zt, teacherSignal, st, studentSlots);</span><br></pre></td></tr></table></figure>

<p><strong>所以，如果出现了重载，那么在连接函数的时候就需要通过函数指针处理一下。</strong></p>
<p>注意，如果打印的是QString类型，会自动给你填上引号。不过可以将其转化为char*的字符串类型。</p>
<p>一种方式是在QString后面调用一下.toUtf8()，本质是先将QString转化为QByteArray， 再转为Char *。这里可以先转化为ByteArray， 然后再调用data就可以了。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QDebug</span>() &lt;&lt; <span class="string">&quot;请老师吃饭，老师要吃：&quot;</span> &lt;&lt; foodName.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>() ;</span><br></pre></td></tr></table></figure>

<p>QString转化为Char *的一种方法。</p>
<h3 id="信号连接信号"><a href="#信号连接信号" class="headerlink" title="信号连接信号"></a>信号连接信号</h3><p>我们想让老师按下课按钮之后，再下课。可以自定义一个按钮，然后检测这个按钮是否被点击了，如果被点击了，就对当前的窗口类执行ClassIsOver函数，进而触发老师饿了的信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn = new QPushButton(&quot;下课&quot;, this);</span><br><span class="line">connect(btn, &amp;QPushButton::clicked, this, &amp;Widget::ClassIsOver);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相当于点击按钮之后，触发下课函数，进而使得老师发出hugry信号，引发槽函数的调用。本质是直接让Click这个信号连接学生请客这个槽。</p>
<p>其实，我们有另一种操作：将信号和信号相连，然后再让这个信号和槽连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(btn, &amp;QPushButton::clicked, zt, &amp;Teacher::hungry);//让click信号和hungry信号相连</span><br></pre></td></tr></table></figure>

<p>这样，当btn检测到被点击的信号的时候，会直接引发hungry信号。而不需要ClassIsOver这个槽函数作为过渡，去激发下一轮的信号。上面前一个例子，是将btn检测到按钮clicked的信号之后，传递到当前窗口界面调用ClassIsOver函数，进而实现下一轮信号的触发。这里，窗口界面类作为接收者，其ClassIsOver函数就相当于槽函数了！</p>
<p>断开信号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(...)</span><br></pre></td></tr></table></figure>

<p>disconnect的内容，跟当初connect的内容是一样的。这样就能够实现信号的断开了。</p>
<p>这里可以进行信号的传递。</p>
<h3 id="信号与槽的补充知识"><a href="#信号与槽的补充知识" class="headerlink" title="信号与槽的补充知识"></a>信号与槽的补充知识</h3><ul>
<li>信号是可以连接信号的</li>
<li>一个信号是可以连接多个槽函数的。也就是，当信号的输出者触发某个信号的时候，可能会带来一系列的后果。</li>
<li>多个信号可以连接同一个槽函数。可以通过多种不同方式触发同一个槽函数。</li>
<li>信号和槽函数的参数必须一一对应。可以形象地用“槽”的形状来理解，信号提供的“参数插口”必须和槽的“参数接口相同的”。不过，信号和槽的参数个数，不一定是要一致的。信号的参数个数可以比槽的参数更多，而槽函数的参数个数不能多于信号的参数个数。可以理解为，槽函数需要知道一系列细节来执行操作，如果信号内部没有给出对应的参数信息，那么就不能执行对应的操作。</li>
<li>槽函数和信号在类型上必须严格地一致！如Click的参数，是需要一个Bool类型的。</li>
</ul>
<h2 id="四、QMainWindow"><a href="#四、QMainWindow" class="headerlink" title="四、QMainWindow"></a>四、QMainWindow</h2><p>QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏、多个工具栏、多个锚接部件（可以浮动）、一个状态栏（位于下方）以及一个中心部件（Central Widget），是许多应用程序的基础，比如文本编辑器，图片编辑器等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//菜单栏创建</span><br><span class="line">QMenuBar * bar = menuBar();</span><br><span class="line">//将菜单栏放入到窗口中，源码已经将菜单栏放到对象树上了</span><br><span class="line">setMenuBar(bar);//空的，不会显示</span><br><span class="line">//创建菜单</span><br><span class="line">bar-&gt;addMenu(&quot;Flie&quot;);</span><br><span class="line">//这时就会多添加一个菜单了</span><br><span class="line">//创建菜单项</span><br><span class="line">fileMenu-&gt;addAction(&quot;新建&quot;);</span><br><span class="line">//这样在菜单栏的最上面，点开文件菜单，会看到“新建”的菜单项目。</span><br><span class="line">//我们可以利用菜单项来添加分隔符</span><br><span class="line">fileMenu-&gt;addSeparator();//这就是添加分割线，菜单栏里面的打开和新建之间就会有一个分割线</span><br><span class="line">fileMenu-&gt;addAction(&quot;打开&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//工具栏创建，可以有多个</span><br><span class="line">QToolBar * toolBar = new QToolBar(this);//生成工具栏，放到对象树上，可以不用管释放</span><br><span class="line">addToolBar(toolBar);//这样就能将工具栏添加到界面上了！</span><br><span class="line">//细节，报错invalid use of... 一般是没有用头文件引起的。</span><br><span class="line">//我们还可以设置工具栏在图形化界面上所处的位置！</span><br><span class="line">addToolBar(Qt::LeftToolBarArea, toolBar);//这里前一个参数是在设置工具栏的位置，后一个是我们的工具栏指针。</span><br><span class="line">//一般，QT中的所有枚举值都是Qt::可以打出来！</span><br><span class="line"></span><br><span class="line">//后期设置，只允许左右停靠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="五、资源文件的补充"><a href="#五、资源文件的补充" class="headerlink" title="五、资源文件的补充"></a>五、资源文件的补充</h2><h3 id="图片文件"><a href="#图片文件" class="headerlink" title="图片文件"></a>图片文件</h3><p>首先需要将图片文件拷贝到项目位置下，然后右键项目，添加新文件，QT-&gt;QTResource File，然后给资源文件起名，再用res生成res.qre</p>
<p>后续可以用Open in editor打开 编辑资源。</p>
<p>可以先添加前缀，再添加文件。</p>
<h1 id="框架代码阅读"><a href="#框架代码阅读" class="headerlink" title="框架代码阅读"></a>框架代码阅读</h1><h2 id="0-形而上的理解："><a href="#0-形而上的理解：" class="headerlink" title="0.形而上的理解："></a>0.形而上的理解：</h2><p>所有游戏中看得见与看不见的物体，统称为游戏对象，而所有这些游戏对象共同组成游戏场景。</p>
<p>GameObject类对应游戏对象，GameObject下挂载的Component负责执行游戏逻辑并更新游戏场景。</p>
<p>GameScene类对应游戏场景，处理显示和渲染部分的操作。</p>
<p>Component类对应游戏对象所拥有的一些属性，例如玩家操作的人物需要显示表示玩家的图片、可以通过键盘移动、可以受到炸弹伤害等等。</p>
<p>其中，一个GameObject最多只有一个Transform Component，对应游戏对象的绘制。</p>
<h2 id="1-以圆的绘制为例"><a href="#1-以圆的绘制为例" class="headerlink" title="1.以圆的绘制为例"></a>1.以圆的绘制为例</h2><p>在框架的mainwindow.cpp的loadScene()中，加上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsEllipseItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadScene</span><span class="params">(GameScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> obj = <span class="keyword">new</span> <span class="built_in">GameObject</span>();<span class="comment">//新建一个游戏对象obj</span></span><br><span class="line"><span class="keyword">auto</span> transform = <span class="keyword">new</span> <span class="built_in">Transform</span>();<span class="comment">//新建了一个游戏对象的显示组件</span></span><br><span class="line"><span class="keyword">auto</span> circle = <span class="keyword">new</span> <span class="built_in">QGraphicsEllipseItem</span>(transform);<span class="comment">//实例化一个QGraphicsEllipseItem，挂载到transform下用于绘制一个圆</span></span><br><span class="line">circle-&gt;<span class="built_in">setRect</span>(<span class="number">-5</span>, <span class="number">-5</span>, <span class="number">10</span>, <span class="number">10</span>);<span class="comment">//这是QGraphicsEllipseItem中的函数setRect，四个参数是x,y和w,h。(x,y)用来显示其坐标，w和h分别表示这个圆的宽和高，当w=h的时候，也就是一个圆了，当w!=h的时候，将会是一个椭圆</span></span><br><span class="line">transform-&gt;<span class="built_in">setPos</span>(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//这是在将游戏对象的Transform组件移动到场景的(100,100)处</span></span><br><span class="line">obj-&gt;<span class="built_in">addComponent</span>(transform);<span class="comment">//对于我们刚刚定义的游戏对象obj，将transform组件挂载到obj上，使其具有相应的绘图的性质</span></span><br><span class="line">scene-&gt;<span class="built_in">attachGameObject</span>(obj);<span class="comment">//这是在将obj游戏对象挂载到当前游戏场景上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这个例子，我们可以总结出框架为我们提供的功能。</p>
<p>首先，声明一个游戏对象的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Obj = <span class="keyword">new</span> <span class="built_in">GameObject</span>();</span><br></pre></td></tr></table></figure>

<p>这里新声明了一个游戏对象，并用auto关键字声明了一个指向这个游戏对象的指针。</p>
<p>其次，声明某个游戏对象的显示组件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> transform = <span class="keyword">new</span> <span class="built_in">Transform</span>();</span><br></pre></td></tr></table></figure>

<p>这样就声明出了一个游戏对象的显示组件</p>
<p>对于显示组件的移动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform-&gt;<span class="built_in">setPos</span>(x,y);</span><br></pre></td></tr></table></figure>

<p>这是将显示组件运送到(x,y)处</p>
<p>对于将组件挂载到游戏对象上的写法：可以通过组件挂载函数addComponent和目标挂载组件transform结合来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj-&gt;<span class="built_in">addComponent</span>(transform);</span><br></pre></td></tr></table></figure>

<p>然后，还可以将游戏对象挂载到游戏场景上，这样就能够在游戏场景的MainWindow上显示出来了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene-&gt;<span class="built_in">attachGameObject</span>(obj);</span><br></pre></td></tr></table></figure>



<h2 id="2-如何加载图片？"><a href="#2-如何加载图片？" class="headerlink" title="2.如何加载图片？"></a>2.如何加载图片？</h2><p>给出如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;transformbuilder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadScene</span><span class="params">(GameScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> obj = <span class="keyword">new</span> <span class="built_in">GameObject</span>();<span class="comment">//新声明一个游戏对象</span></span><br><span class="line">	<span class="built_in">ImageTransformBuilder</span>()</span><br><span class="line">		.<span class="built_in">setPos</span>(<span class="built_in">QPointF</span>(<span class="number">100</span>, <span class="number">100</span>))<span class="comment">//这里是图片显示的坐标</span></span><br><span class="line">		.<span class="built_in">setImage</span>(<span class="string">&quot;C:/project/image/enemy.png&quot;</span>)<span class="comment">//这里是图片显示的路径</span></span><br><span class="line">		.<span class="built_in">setAlignment</span>(Qt::AlignCenter)<span class="comment">//这样图片的正中心就位于(100,100)</span></span><br><span class="line">		.<span class="built_in">addToGameObject</span>(obj);<span class="comment">//将这个组件挂载到游戏对象身上</span></span><br><span class="line">	scene-&gt;<span class="built_in">attachGameObject</span>(obj);<span class="comment">//将游戏对象挂载到游戏场景中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Qt::AlignLeft | Qt::AlignTop可以用于指定图片的左上角位于(x,y)处</span></span><br></pre></td></tr></table></figure>

<p>注意，这里必须要用右斜杠，因为Windows默认路径设置为左斜杠，在设置路径的时候一定注意！</p>
<p>上述代码是绝对路径下的图片加载，然而我们在做gitpush的时候，是不能将本地的资源文件push到github classroom里的。我们需要做的是，使用相对路径的方式。</p>
<h3 id="关于Qt资源文件qrc的使用"><a href="#关于Qt资源文件qrc的使用" class="headerlink" title="关于Qt资源文件qrc的使用"></a>关于Qt资源文件qrc的使用</h3><p>通过Qt Creator添加资源文件.qrc的方式，可以实现非绝对路径添加图片的操作。我们需要在工程目录下加载图片，然后保存到资源文件.qrc中。这样，最终编译出的图片数据会以二进制格式存储在.qrc中。</p>
<p>关于.qrc的使用：</p>
<ul>
<li>先在Qt Creator中创建资源库，生成一个.qrc文件</li>
<li>然后，一定需要编辑一系列Prefix作为前缀。该步骤的本质是在分类。</li>
<li>然后，在工程目录对应的文件夹下载入资源文件</li>
<li>在Qt Creator的对应资源文件中，载入所需的图片资源。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> obj = <span class="keyword">new</span> <span class="built_in">GameObject</span>();</span><br><span class="line"><span class="built_in">ImageTransformBuilder</span>()</span><br><span class="line">        .<span class="built_in">setPos</span>(<span class="built_in">QPointF</span>(<span class="number">100</span>, <span class="number">100</span>))<span class="comment">//设置添加图片的坐标</span></span><br><span class="line">        .<span class="built_in">setImage</span>(<span class="string">&quot;:/image/pics/1.png&quot;</span>)<span class="comment">//设置添加图片的间接路径</span></span><br><span class="line">        .<span class="built_in">setAlignment</span>(Qt::AlignCenter)<span class="comment">//设置图片的位置，以(100,100)作为图片的中心点</span></span><br><span class="line">        .<span class="built_in">addToGameObject</span>(obj);<span class="comment">//将这个图片性质的配件挂载到游戏对象obj上</span></span><br><span class="line">gameScene-&gt;<span class="built_in">attachGameObject</span>(obj);<span class="comment">//将游戏对象挂载到游戏环境中</span></span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的写法，注意，在相对路径的添加时，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;冒号+/Prefix+/folders+/xxx.png&quot;,eg:&quot;/image/pics/Minecraft.png&quot;</span><br></pre></td></tr></table></figure>

<p>关于图片大小的调整：手动画图hhh（（（</p>
<h2 id="3-让圆动起来"><a href="#3-让圆动起来" class="headerlink" title="3. 让圆动起来"></a>3. 让圆动起来</h2><p>为了让圆动起来，不妨创建一个新的Componenet:Physics</p>
<p>我们希望给Physics组件设置一个速度后，能让GameObject以这个速度一致持续下去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> obj = <span class="keyword">new</span> <span class="built_in">GameObject</span>();</span><br><span class="line"><span class="keyword">auto</span> transform = <span class="keyword">new</span> <span class="built_in">Transform</span>();</span><br><span class="line"><span class="keyword">auto</span> circle = <span class="keyword">new</span> <span class="built_in">QGraphicsEllipseItem</span>(transform);</span><br><span class="line">circle −&gt;<span class="built_in">setRect</span> (−<span class="number">5</span>,−<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>) ;</span><br><span class="line">transform−&gt;<span class="built_in">setPos</span> (<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">obj−&gt;<span class="built_in">addComponent</span> (transform);</span><br><span class="line">obj−&gt;<span class="built_in">addComponent</span> (<span class="keyword">new</span> <span class="built_in">Physics</span>());</span><br><span class="line">obj−&gt;<span class="built_in">addComponent</span> (<span class="keyword">new</span> <span class="built_in">UserController</span>());</span><br><span class="line">gameScene−&gt;<span class="built_in">attachGameObject</span> (obj);</span><br></pre></td></tr></table></figure>

<p>注意，Physic组件用来控制游戏对象的物理特性，包括位移速度等等</p>
<p>而Usercontroller组件用来表示游戏对象是否会受到玩家的控制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/04/03/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">学习规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-03 00:06:31" itemprop="dateCreated datePublished" datetime="2022-04-03T00:06:31+08:00">2022-04-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/04/02/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/" class="post-title-link" itemprop="url">随笔（一）：姗姗来迟的反省与思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-02 23:59:01" itemprop="dateCreated datePublished" datetime="2022-04-02T23:59:01+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 09:53:15" itemprop="dateModified" datetime="2022-05-10T09:53:15+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">随笔杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在最前面："><a href="#写在最前面：" class="headerlink" title="写在最前面："></a>写在最前面：</h2><p>现在是2022年4月4日，这是本博客的第一篇随笔。</p>
<p>制作这个博客的初衷，是希望自己能够在信息时代有一方自己的小岛，能在其上桑蚕养鱼，分享技术，记录心情。我并不是一个特别喜欢将内心世界分享给别人的人，所以绝大多数情况，这个博客是写给自己看的，相当于日记吧。文章内容可能偏向意识流，前后不会有很连贯的逻辑关系，想到哪说哪好了！这一篇随笔，其实应该高考结束之后就写的，用来矫枉过正自己的学习状态和生活状态。所以加了定语“姗姗来迟”</p>
<h2 id="从学习谈起："><a href="#从学习谈起：" class="headerlink" title="从学习谈起："></a>从学习谈起：</h2><p>  从小便是在应试的体制下成长，量化学习指标的最直接方式，自然就是分数了。很多时候，我在学习的是真正的知识吗？并不是，可能很多情况是一些解题的方法和技巧罢了。追逐分数本身并不能称其为坏事，可是过于追逐分数，则显然是一件糟糕至极的事情了，这违背了学习的意义所在。为了分数，学生们开始攀比，恶性竞争（所谓内卷）。学校不再将素质教育、传道授业、培养学习习惯作为首要任务，而将升学率、清北率、分数作为唯一指标。这样的环境下，真的能够出大师么？最终导致学生浮夸虚荣、追名逐利、急功近利的学习习惯。当然，这是我目前的学习漏洞之一——不求甚解，没有细细思考、咀嚼、品味，囫囵吞下去甚至懒得吞咽，面向分数学习，急功近利没有坐冷板凳的定力与耐心…..是的，量化的指标似乎总能说明问题：我刷了成千上万道题、做了几吨的卷子、摞起来有几人高…..网络上对所谓学霸的吹捧，似乎也是这样。我曾经就看过公众号对学霸的报道：做完了一人高的试卷最终考入清北。似乎，学习真的能够量化。这，在我看来，是十分错误的。中国乃至亚洲都过分夸大了努力的重要性，“干就完了”，却不曾强调努力的方法论。没有意识到，学习是需要领悟的，而这个领悟、感受的过程，我认为最为重要；将知识记忆、综合；再将其投入实践、应用的训练中。然后，再在之后的事件内投入一定的训练、温故知新，只有如是才算真正地在学习。然而，在领悟、感受、接触、认知的过程中，通常不会有什么直观的学习成果产出，可是却为后续的学习奠基、如大树向下扎根一般。如，我在南京大学计算机拔尖班，上过一门课叫问题求解。这门课许多阅读材料的内容，如若只是为了应付作业，则可以很简单地完成。可如果想要把握主旨思想，则需精读、实践。</p>
<p>  所以，学习上要注意的第一点：切忌急功近利爱慕虚荣，切记人外有人天外有天。做足冷板凳、扎好马步才是练功的基础。知识不是用来炫耀的。而获取知识的过程，一定要有耐心、细心。无论投入多少时间，都要仔细地将问题吃深吃透。不要着急出成果，不要着急能够学完了立刻完成作业、提高多少分，要舍得投入时间、精力、耐得住性子，持续不断地坚持努力，才能够得到更多的提升。时刻保持谦卑，耐心、细心、定力。</p>
<p>  其次，身为信息时代的原住民，我们从小就生活在碎片化的时代中。被各种支离破碎的新闻、花边舆论裹挟，互联网将各种情绪混成一锅粥，再放大作用到每个人身上。焦虑的情绪蔓延到每个人的身心。因此，专心和专注在这个加速时代显得尤为重要。看过一篇报道，手机App的营销策略，就是如何能够最大程度地攫取人们地注意力。或称“注意力经济”。而根据西方学者的理论，这些信息多数产自“奶头乐”，我们被这些信息侵蚀了心智、分散了精力，以至于无法将时间和精力投入到更有意义、能够真正带来个人提升的事情上。</p>
<p>  自然的，对于学习上要注意的第二个方面：要专心、细心，在进行学习的过程中心无旁骛，能达到“心流”状态是最好的。不过，我们至少应该屏蔽一些诱惑，如手机、网络游戏….专心致志，如放大镜聚光一样组织自己的时间和精力，无疑是最有效率的方法。当然，要注意劳逸结合，适度放松还是必要的。</p>
<p>  最后，学习要注意的第三个方面：是坚持不懈，是执着、有毅力有决心地去完成一个又一个学习任务。不要盲目听从他人的建议，在确认自己学习的方法正确后，要坚定不移地前进下去。自律自强，方能月中折桂。</p>
<p>  浮躁虚荣、没有定力、自律性差、专心不足，此乃大忌，切记切记。</p>
<h2 id="何去何从？"><a href="#何去何从？" class="headerlink" title="何去何从？"></a>何去何从？</h2><p>如何改正我的学习习惯和学习态度呢？思索一二，先从习惯培养开始吧。</p>
<p>注意力、专心，可以用阅读、听力的方式培养。</p>
<p>戒骄戒躁。如本学期问题求解，不读完所有材料，做完所有练习、研究完OT、思考完选做题，不动作业。写作业时反复思考，有无更优的解法？对于OJ作业，不再追逐名次，而谦虚地学习题解，讨论做法和思路。如本学期数电，耐心看完所有视频，再读课本和习题指导，最后再动作业。如微积分，一定吃透所有地概念和定义，再下笔，思考，永远先于行动，而行动，永远基于思考的结果。</p>
<p>暂时先想到这里，便搁笔于此。</p>
<p>​                2022年4月4日 笔者于南京大学择善楼。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ultrahjr.github.io/2022/04/02/Test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wind">
      <meta itemprop="description" content="Welcome to my Ark!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wind's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/Test/" class="post-title-link" itemprop="url">基础Hexo博客使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-02 16:52:24" itemprop="dateCreated datePublished" datetime="2022-04-02T16:52:24+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 19:17:06" itemprop="dateModified" datetime="2022-05-10T19:17:06+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/" itemprop="url" rel="index"><span itemprop="name">Computer Technology</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Technology/Hexo%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">Hexo博客技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-基础Hexo指令"><a href="#1-基础Hexo指令" class="headerlink" title="1. 基础Hexo指令"></a>1. 基础Hexo指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server </span><br></pre></td></tr></table></figure>

<p>将hexo服务器在本地开启，可以通过local端口访问查看实际效果。可用s替代server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态的配置文件，generate可简写为g</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>将生成的hexo文件内容部署到远程仓库中，实现远端页面的内容更新和维护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除hexo文件的缓存，用于数据更新的时候重新生成静态文件。</p>
<h1 id="2-添加新文章、页面"><a href="#2-添加新文章、页面" class="headerlink" title="2. 添加新文章、页面"></a>2. 添加新文章、页面</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &lt;layout&gt; [name]</span><br></pre></td></tr></table></figure>

<p>layout用于选择生成新文件的格式。默认为post。[name]处填写需要生成的文件名，需要加双引号。此外还有page、draft两种layout.前者是一种页面格式，用于生成类似category、tags左边栏的分类文件内容。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>添加了分类页面。</p>
<p>接着，在分类文件夹中，找到index.md，这是分类页面的配置markdown文本。将其内容进行适当修改，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: xxx..</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>最下面的type用于文章front-matter的设置，可以在文章的题头写上：</p>
<p>categories: 数学,则这篇文章就会被分到“数学”这一类内容上。</p>
<h1 id="3-添加图片内容"><a href="#3-添加图片内容" class="headerlink" title="3.添加图片内容"></a>3.添加图片内容</h1><p>在使用插件hexo-renderer-marked之后，可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<p>的方式添加文件。同时，这里的image.jpg应当存储在文章对应的文件资源管理文件夹中。</p>
<p><img src="/2022/04/02/Test/1.png" alt="1"></p>
<p>注意，我们这里的文件路径不需要填写绝对路径。只需要填写在source文件夹内，_Post文件夹中，对应文件管理器中图片的名字即可！</p>
<p>另外，对于网络图片，我们可以在括号内添加网址即可实现加载！</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-efe56ba165422131f310fe541212faa8_1440w.jpg%3Fsource%3D172ae18b&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1651489035&t=8a6a0245cf21fbad3faf99601e2f9bd5"></p>
<p>对于花括号的输入，不能用传统的LaTex代码来实现，而应当使用如下的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \lbrace CONTENT \rbrace $</span><br></pre></td></tr></table></figure>

<p>这样直接进行范围界定才能在服务器正常显示</p>
<p>效果：$\lbrace x_1, x_2, … x_n\rbrace$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wind"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wind</p>
  <div class="site-description" itemprop="description">Welcome to my Ark!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wind</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
